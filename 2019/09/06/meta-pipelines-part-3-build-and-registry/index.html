<!doctype html><html lang=en><meta charset=utf-8><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/blog.casavian.eu\/"},"articleSection":"post","name":"Meta-pipelines - Part 3 - Build and Registry","headline":"Meta-pipelines - Part 3 - Build and Registry","description":"Notes and considerations of small venetian guy on DevOps tools, architecture, development and other paraphernalia.","inLanguage":"en","author":"Giulio Vian","creator":"Giulio Vian","publisher":"Giulio Vian","accountablePerson":"Giulio Vian","copyrightHolder":"Giulio Vian","copyrightYear":"2019","datePublished":"2019-09-06T00:00:00Z","dateModified":"2019-09-06T00:00:00Z","url":"\/2019\/09\/06\/meta-pipelines-part-3-build-and-registry\/","wordCount":"625","keywords":["Build","Pipelines","Azure DevOps","Docker","Blog"]}</script><title>Meta-pipelines - Part 3 - Build and Registry &ndash; Giulio Vian's Blog!</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="Notes and considerations of small venetian guy on DevOps tools, architecture, development and other paraphernalia."><meta name=author content="Giulio Vian"><link rel=icon href=/favicon.ico><meta itemprop=name content="Meta-pipelines - Part 3 - Build and Registry"><meta itemprop=description content="In the previous instalments we examined a possible Dockerfile for an Azure Pipelines/TFS Agent. In this post, we will explore the pipeline that can automatically build such custom agent images.
Docker Registry To automate properly we need a Docker Registry where storing the Docker images we build. There are many advantages in using a registry, in our scenario it enables:
 pulling an image version built years ago distribution of images to multiple hosts caching locally base images, allowing air gap builds  For the purpose of this series we will use Azure Container Registry (ACR for short), but there are many options; for example I used successfully ProGet &nbsp; ."><meta itemprop=datePublished content="2019-09-06T00:00:00+00:00"><meta itemprop=dateModified content="2019-09-06T00:00:00+00:00"><meta itemprop=wordCount content="625"><meta itemprop=image content="http://blog.casavian.eu/2019/09/06/meta-pipelines-part-3-build-and-registry/feature-banner.jpg"><meta itemprop=keywords content="Build,Pipelines,Azure DevOps,Docker,"><meta property="og:title" content="Meta-pipelines - Part 3 - Build and Registry"><meta property="og:description" content="In the previous instalments we examined a possible Dockerfile for an Azure Pipelines/TFS Agent. In this post, we will explore the pipeline that can automatically build such custom agent images.
Docker Registry To automate properly we need a Docker Registry where storing the Docker images we build. There are many advantages in using a registry, in our scenario it enables:
 pulling an image version built years ago distribution of images to multiple hosts caching locally base images, allowing air gap builds  For the purpose of this series we will use Azure Container Registry (ACR for short), but there are many options; for example I used successfully ProGet &nbsp; ."><meta property="og:type" content="article"><meta property="og:url" content="http://blog.casavian.eu/2019/09/06/meta-pipelines-part-3-build-and-registry/"><meta property="og:image" content="http://blog.casavian.eu/2019/09/06/meta-pipelines-part-3-build-and-registry/feature-banner.jpg"><meta property="article:published_time" content="2019-09-06T00:00:00+00:00"><meta property="article:modified_time" content="2019-09-06T00:00:00+00:00"><meta property="og:site_name" content="Giulio Vian's Blog!"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://blog.casavian.eu/2019/09/06/meta-pipelines-part-3-build-and-registry/feature-banner.jpg"><meta name=twitter:title content="Meta-pipelines - Part 3 - Build and Registry"><meta name=twitter:description content="In the previous instalments we examined a possible Dockerfile for an Azure Pipelines/TFS Agent. In this post, we will explore the pipeline that can automatically build such custom agent images.
Docker Registry To automate properly we need a Docker Registry where storing the Docker images we build. There are many advantages in using a registry, in our scenario it enables:
 pulling an image version built years ago distribution of images to multiple hosts caching locally base images, allowing air gap builds  For the purpose of this series we will use Azure Container Registry (ACR for short), but there are many options; for example I used successfully ProGet &nbsp; ."><meta name=twitter:site content="@giulio_vian"><link rel=alternate href=/index.xml type=application/rss+xml title="Giulio Vian's Blog!"><link rel=stylesheet href=/css/vendor.min.95b0b4c4607aec507f0fc9d9c36a12a4613ccac06f9423caa43e265cb58eb5f90709388cc0fa166ac3ca836b4163e6d0569b8b86065d9cabdf223c5ea9a63b08.css integrity="sha512-lbC0xGB67FB/D8nZw2oSpGE8ysBvlCPKpD4mXLWOtfkHCTiMwPoWasPKg2tBY+bQVpuLhgZdnKvfIjxeqaY7CA=="><link href=http://blog.casavian.eu/css/cookieconsent.min.cd0d0b6e50ff01ff2f3a9a70d7cfb66a7c6cb9acf7a566325568be6d3bd31fc4.css rel=stylesheet type=text/css integrity="sha256-zQ0LblD/Af8vOppw18+2anxsuaz3pWYyVWi+bTvTH8Q=" crossorigin=anonymous><script src=http://blog.casavian.eu/js/cookieconsent.min.e55842a856a6d829feca3c3ad736c136b6c7549e9247274f78aa296259e06e24.js integrity="sha256-5VhCqFam2Cn+yjw61zbBNrbHVJ6SRydPeKopYlngbiQ=" crossorigin=anonymous async></script><script>window.addEventListener("load",function(){window.cookieconsent.initialise({"palette":{"popup":{"background":"#428bca","text":"#ffffff"},"button":{"background":"#f71559"}},"content":{"message":'This website uses cookies.',"dismiss":'Got it!',"link":'Learn more.',"href":"http:\/\/blog.casavian.eu\/page\/privacy-cookies-policy\/"},"position":"bottom-right"})});</script><body><nav class="navbar navbar-light bg-white navbar-expand-lg border-bottom"><div class=container><a class="navbar-brand text-primary" href=/>Giulio Vian's Blog!</a>
<button class="navbar-toggler collapsed" type=button data-toggle=collapse data-target=#navbarCollapse aria-controls=navbarCollapse aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="navbar-collapse collapse" id=navbarCollapse><ul class="navbar-nav mr-auto"><li class=nav-item><a class="nav-link text-primary" href=/index.html><i class="fas fa-home"></i>Home</a></li><li class=nav-item><a class="nav-link text-primary" href=/page/about/><i class="fa fa-info-circle"></i>About</a></li><li class=nav-item><a class="nav-link text-primary" href=/page/public-speaking><i class="fa fa-microphone"></i>Speaking</a></li></ul></div></div></nav><main role=main><div class="container mt-3 mb-3"><div class=card><img class=card-img-top src=/2019/09/06/meta-pipelines-part-3-build-and-registry/feature-banner_hu34c3e573966966cb30c13e11fba0381d_392742_1108x0_resize_q75_box.jpg alt="Meta-pipelines - Part 3 - Build and Registry" title="Meta-pipelines - Part 3 - Build and Registry"><div class=card-body><h1 class=card-title><a href=/2019/09/06/meta-pipelines-part-3-build-and-registry/>Meta-pipelines - Part 3 - Build and Registry</a></h1><h6 class="card-subtitle mb-2 text-muted"><i class="fas fa-calendar-day"></i>&nbsp;06 Sep 2019 -
<i class="fas fa-user"></i>&nbsp;Giulio Vian
- <i class="fas fa-clock"></i>&nbsp;~3 Minutes</h6><p class=card-text><p>In the previous instalments we examined a possible Dockerfile for an Azure Pipelines/TFS Agent. In this post, we will explore the pipeline that can automatically build such custom agent images.</p><h2 id=docker-registry>Docker Registry</h2><p>To automate properly we need a Docker Registry where storing the Docker images we build.
There are many advantages in using a registry, in our scenario it enables:</p><ul><li>pulling an image version built years ago</li><li>distribution of images to multiple hosts</li><li>caching locally base images, allowing air gap builds</li></ul><p>For the purpose of this series we will use Azure Container Registry (ACR for short), but there are many options; for example I used successfully <a href=https://inedo.com/proget target=_blank rel="noopener noreferrer">ProGet
&nbsp;<i class="fas fa-external-link-alt"></i>
</a>.
To setup your ACR, see the <a href=https://docs.microsoft.com/en-us/azure/container-registry/ target=_blank rel="noopener noreferrer">quick-starts
&nbsp;<i class="fas fa-external-link-alt"></i>
</a>.</p><h2 id=image-build-pipeline>Image Build Pipeline</h2><p>The idea is to define a build pipeline for each flavour of dockerised build agent: for example, an agent for .Net Core 2.2, one for .Net Core 3.0, etc. Such build pipeline will build the docker image and push it to a Docker Registry.
A deploy pipeline takes care of starting containers on the host machines after pulling the image from the registry. This is a little complicated as we must stop any running container of that flavour and run the required instances.</p><p>As the Dockerfile works either on Windows or Linux, it is important to add the proper <code>Agent.OS</code> demand on these pipelines so that they execute on hosts with matching operating system.</p><p>As we foresee to have a number of specialized agents, we want to maintain as little code as possible. Here I will use an Azure Pipelines YAML template, so that each specific YAML build simply sets the parameters value required.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#66d9ef>parameters</span>:
  <span style=color:#66d9ef>os</span>: <span style=color:#e6db74>&#39;&#39;</span>
  <span style=color:#66d9ef>toolchain</span>: <span style=color:#e6db74>&#39;&#39;</span>
  <span style=color:#66d9ef>toolchain_version</span>: <span style=color:#e6db74>&#39;&#39;</span>
  <span style=color:#66d9ef>repo_docker_path</span>: <span style=color:#e6db74>&#39;src/agents/docker&#39;</span>
  <span style=color:#66d9ef>image_name_prefix</span>: <span style=color:#e6db74>&#39;azure-pipelines-agent&#39;</span>
  <span style=color:#66d9ef>docker_registry_connection</span>: <span style=color:#e6db74>&#39;mydemo.azurecr.io&#39;</span>

<span style=color:#66d9ef>steps</span>:
- <span style=color:#66d9ef>task</span>: Docker@<span style=color:#ae81ff>2</span>
  <span style=color:#66d9ef>displayName</span>: Login to Docker Registry
  <span style=color:#66d9ef>inputs</span>:
    <span style=color:#66d9ef>command</span>: login
    <span style=color:#66d9ef>containerRegistry</span>: <span style=color:#e6db74>&#39;${{ parameters.docker_registry_connection }}&#39;</span>
- <span style=color:#66d9ef>task</span>: Docker@<span style=color:#ae81ff>2</span>
  <span style=color:#66d9ef>displayName</span>: <span style=color:#e6db74>&#39;Building ${{ parameters.toolchain }} ${{ parameters.toolchain_version }} image&#39;</span>
  <span style=color:#66d9ef>inputs</span>:
    <span style=color:#66d9ef>command</span>: buildAndPush
    <span style=color:#66d9ef>repository</span>: <span style=color:#e6db74>&#39;${{ parameters.image_name_prefix }}/${{ parameters.os }}/${{ parameters.toolchain }}&#39;</span>
    <span style=color:#66d9ef>dockerFile</span>: <span style=color:#e6db74>&#39;${{ parameters.repo_docker_path }}/${{ parameters.os }}/${{ parameters.toolchain }}_${{ parameters.toolchain_version }}/Dockerfile&#39;</span>
    <span style=color:#66d9ef>imageName</span>: <span style=color:#e6db74>&#39;${{ parameters.image_name_prefix }}/${{ parameters.os }}/${{ parameters.toolchain }}-${{ parameters.toolchain_version }}&#39;</span>
    <span style=color:#66d9ef>tags</span>: <span style=color:#e6db74>|
</span><span style=color:#e6db74>      ${{ parameters.toolchain_version }}</span>
      latest
</code></pre></div><p>The template is straightforward: it runs docker twice, one to login to a Docker Registry (ACR in this example) and next to build the image from the Docker file and push the image to the Registry.</p><p>Using the template is also simple, invoke the template passing the parameters.
You will note the <strong>MakeAgents</strong> queue; you will probably remember from the first instalment that this pool has the agents running on host machines. The demand for <code>Windows_NT</code> will pick the right host type matching the Dockerfile requirement.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#66d9ef>trigger</span>:
  <span style=color:#66d9ef>batch</span>: <span style=color:#66d9ef>true</span>
  <span style=color:#66d9ef>paths</span>:
    <span style=color:#66d9ef>include</span>:
      - src/agents/*
<span style=color:#66d9ef>pool</span>:
  <span style=color:#66d9ef>name</span>: MakeAgents
  <span style=color:#66d9ef>demands</span>:
  - agent.os -equals Windows_NT
<span style=color:#66d9ef>steps</span>:
- <span style=color:#66d9ef>template</span>: templates/build-image.yaml
  <span style=color:#66d9ef>parameters</span>:
    <span style=color:#66d9ef>os</span>: <span style=color:#e6db74>&#39;windows&#39;</span>
    <span style=color:#66d9ef>toolchain</span>: <span style=color:#e6db74>&#39;dotnet-core&#39;</span>
    <span style=color:#66d9ef>toolchain_version</span>: <span style=color:#e6db74>&#39;2.2&#39;</span>
</code></pre></div><p>To build a Linux agent we use the same template, just change the invocation.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#66d9ef>trigger</span>:
  <span style=color:#66d9ef>batch</span>: <span style=color:#66d9ef>true</span>
  <span style=color:#66d9ef>paths</span>:
    <span style=color:#66d9ef>include</span>:
      - src/agents/*
<span style=color:#66d9ef>pool</span>:
  <span style=color:#66d9ef>name</span>: MakeAgents
  <span style=color:#66d9ef>demands</span>:
  - agent.os -equals Linux
<span style=color:#66d9ef>steps</span>:
- <span style=color:#66d9ef>template</span>: templates/build-image.yaml
  <span style=color:#66d9ef>parameters</span>:
    <span style=color:#66d9ef>os</span>: <span style=color:#e6db74>&#39;linux&#39;</span>
    <span style=color:#66d9ef>toolchain</span>: <span style=color:#e6db74>&#39;angular&#39;</span>
    <span style=color:#66d9ef>toolchain_version</span>: <span style=color:#e6db74>&#39;ng&#39;</span>
</code></pre></div><p>The file organisation reflects the naming conventions:</p><p><figure class=image-caption><a href=/2019/09/06/meta-pipelines-part-3-build-and-registry/source-code-organisation.png><img loading=lazy height=513 width=275 style=max-width:100%;height:auto srcset="/2019/09/06/meta-pipelines-part-3-build-and-registry/source-code-organisation.png 500w," src=/2019/09/06/meta-pipelines-part-3-build-and-registry/source-code-organisation.png alt="Source Code Organisation"></a><figcaption></figcaption></figure></p><p>The <em>agents</em> folder has everything needed to build and deploy the agents, <em>pipelines</em> has the Azure Pipelines scripts in the form of YAML definitions and templates, distinguishing between <em>make</em> and <em>deploy</em> categories, i.e. make new Docker images versus starting new Docker containers.
The <em>docker</em> folders is referenced by the pipelines looking for the Docker context, in it we keep <em>windows</em> and <em>linux</em> images apart and finally we have a folder for each Dockerfile and referred scripts.</p><h2 id=whats-next>What&rsquo;s next</h2><p>If we run the above pipelines successfully, we should see, in Azure Portal, two new Repositories (images) in the chosen Docker Registry.</p><p><figure class=image-caption><a href=/2019/09/06/meta-pipelines-part-3-build-and-registry/registry-list-of-repositories.png><img loading=lazy height=255 width=639 style=max-width:100%;height:auto srcset="/2019/09/06/meta-pipelines-part-3-build-and-registry/registry-list-of-repositories_hucf50514667a8f77a54093338ff6345d7_11186_500x0_resize_box_2.png 500w, /2019/09/06/meta-pipelines-part-3-build-and-registry/registry-list-of-repositories.png 800w," src=/2019/09/06/meta-pipelines-part-3-build-and-registry/registry-list-of-repositories.png alt="Images in Docker Registry"></a><figcaption></figcaption></figure></p><p>In future posts we will use these images to create Azure Pipelines Agents.</p></p></div><div class=card-footer><small class=text-muted><i class="fas fa-folder text-primary"></i>&nbsp;
<a href=/categories/#devops class="badge badge-primary"><span>DevOps</span></a><br><i class="fas fa-tags text-secondary"></i>&nbsp;
<a href=/tags/#build class="badge badge-secondary"><span>Build</span></a>
<a href=/tags/#pipelines class="badge badge-secondary"><span>Pipelines</span></a>
<a href=/tags/#azure-devops class="badge badge-secondary"><span>Azure DevOps</span></a>
<a href=/tags/#docker class="badge badge-secondary"><span>Docker</span></a></small></div></div></div></main><footer class="navbar-light border-top"><div class=container><div class=row><div class="col-12 col-md-3 mb-3"><h5>Giulio Vian's Blog!</h5>Notes and considerations of small venetian guy on DevOps tools, architecture, development and other paraphernalia.</div><div class="col-12 col-md-3 mb-3"><h5>Social</h5><ul class="list-unstyled list-inline"><li class=list-inline-item><a href=https://github.com/giuliov target=_blank rel="noopener noreferrer" title=GitHub class="fab fa-github fa-2x"></a></li><li class=list-inline-item><a href=https://stackoverflow.com/users/100864 target=_blank rel="noopener noreferrer" title="Stack Overflow" class="fab fa-stack-overflow fa-2x"></a></li><li class=list-inline-item><a href=https://medium.com/@giuliovdev target=_blank rel="noopener noreferrer" title=Medium class="fab fa-medium fa-2x"></a></li><li class=list-inline-item><a href=https://linkedin.com/in/giuliovian target=_blank rel="noopener noreferrer" title=LinkedIn class="fab fa-linkedin fa-2x"></a></li><li class=list-inline-item><a href=https://linkedin.com/company/unum-ireland-ltd-it target=_blank rel="noopener noreferrer" title="LinkedIn Company" class="fab fa-linkedin fa-2x"></a></li><li class=list-inline-item><a href=https://xing.com/profile/Giulio_Vian target=_blank rel="noopener noreferrer" title=Xing class="fab fa-xing fa-2x"></a></li><li class=list-inline-item><a href=https://slideshare.net/giuliov target=_blank rel="noopener noreferrer" title=SlideShare class="fab fa-slideshare fa-2x"></a></li><li class=list-inline-item><a href=https://youtube.com/UCZ-J6JRyvz6aaJ9zCN5wpxA target=_blank rel="noopener noreferrer" title=YouTube class="fab fa-youtube fa-2x"></a></li><li class=list-inline-item><a href=https://twitter.com/giulio_vian target=_blank rel="noopener noreferrer" title=Twitter class="fab fa-twitter fa-2x"></a></li><li class=list-inline-item><a href=mailto:giulio.dev@casavian.eu title=Email class="fas fa-envelope fa-2x"></a></li></ul></div><div class="col-12 col-md-3 mb-3"><h5>Site</h5><ul class=list-unstyled><li><a href=/about/><i class="fas fa-address-card"></i>About</a></li><li><a href=/categories/><i class="fas fa-folder"></i>Categories</a></li><li><a href=/series/><i class="fas fa-book"></i>Series</a></li><li><a href=/tags/><i class="fas fa-tags"></i>Tags</a></li></ul></div><div class="col-12 col-md-3 mb-3">&copy; 2020 Giulio Vian<br>Theme by <a href=https://www.spech.de target=_blank rel="noopener noreferrer">Sebastian Pech</a>.</div></div></div></footer><script src=/js/vendor.min.0497fa926ed3dc2241b91e016467480841da9749a0f7c40ed3960c3c238745e5accb5ec5e07654668e11047bbf96f95083b88dd49a845781011aba42e4f00a5d.js integrity="sha512-BJf6km7T3CJBuR4BZGdICEHal0mg98QO05YMPCOHReWsy17F4HZUZo4RBHu/lvlQg7iN1JqEV4EBGrpC5PAKXQ=="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-46796059-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>