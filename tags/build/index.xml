<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Build on Giulio Vian's Blog!</title><link>http://blog.casavian.eu/tags/build/</link><description>Recent content in Build on Giulio Vian's Blog!</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><copyright>This work is licensed under a Creative Commons Attribution 4.0 International License</copyright><lastBuildDate>Fri, 20 Sep 2019 00:00:00 +0000</lastBuildDate><atom:link href="http://blog.casavian.eu/tags/build/index.xml" rel="self" type="application/rss+xml"/><item><title>Meta-pipelines - Part 5 - Automating the Host Environment</title><link>http://blog.casavian.eu/2019/09/20/meta-pipelines-part-5-automating-the-host-environment/</link><pubDate>Fri, 20 Sep 2019 00:00:00 +0000</pubDate><guid>http://blog.casavian.eu/2019/09/20/meta-pipelines-part-5-automating-the-host-environment/</guid><description>Looking back at the previous parts of this series, we have been able to manually setup two hosts, a Windows one and a Linux one, and a simple pipeline to automatically deploy new Azure DevOps/TFS Agents in Docker containers on such hosts and even update them.
In this post we will look how to provision the hosts themselves. For this purpose we will use Terraform and invoke it from Azure Pipelines so we can automate host creation in Azure.</description></item><item><title>Meta-pipelines - Part 4 - Deploy and Run</title><link>http://blog.casavian.eu/2019/09/13/meta-pipelines-part-4-deploy-and-run/</link><pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate><guid>http://blog.casavian.eu/2019/09/13/meta-pipelines-part-4-deploy-and-run/</guid><description>In the previous instalment we built custom Docker images for Azure Pipelines/TFS Agents. In this post, we will explore the lifecycle of Docker containers running such images.
Container Deploy Pipeline This pipeline is more complex than the previous requiring 4 actions:
checking if the agent (rectius the container running the agent) is running If so, stop and remove the container Pulling the image from the selected Docker Registry Starting the container with the proper parameters.</description></item><item><title>Meta-pipelines - Part 3 - Build and Registry</title><link>http://blog.casavian.eu/2019/09/06/meta-pipelines-part-3-build-and-registry/</link><pubDate>Fri, 06 Sep 2019 00:00:00 +0000</pubDate><guid>http://blog.casavian.eu/2019/09/06/meta-pipelines-part-3-build-and-registry/</guid><description>In the previous instalments we examined a possible Dockerfile for an Azure Pipelines/TFS Agent. In this post, we will explore the pipeline that can automatically build such custom agent images.
Docker Registry To automate properly we need a Docker Registry where storing the Docker images we build. There are many advantages in using a registry, in our scenario it enables:
pulling an image version built years ago distribution of images to multiple hosts caching locally base images, allowing air gap builds For the purpose of this series we will use Azure Container Registry (ACR for short), but there are many options; for example I used successfully ProGet &amp;nbsp; .</description></item><item><title>Meta-pipelines - Part 2 - Dockerize the agent</title><link>http://blog.casavian.eu/2019/08/30/meta-pipelines-part-2-dockerize-the-agent/</link><pubDate>Fri, 30 Aug 2019 00:00:00 +0000</pubDate><guid>http://blog.casavian.eu/2019/08/30/meta-pipelines-part-2-dockerize-the-agent/</guid><description>In the previous instalment we setup a couple of machines to run Docker and host docker containers. In this post, we will explore the structure of a Dockerfile for Azure Pipelines/TFS Agent.
There is a notable difference between Azure DevOps Service and Server in terms of handling agent updates. The first part of this article can be used in air-gapped environments.
If you need a primer on Docker there is plenty of resources, from the excellent The Docker Book &amp;nbsp; to the official documentation &amp;nbsp; , Pluralsight courses, etc.</description></item><item><title>Meta-pipelines - Part 1 - Docker Hosts</title><link>http://blog.casavian.eu/2019/08/23/meta-pipelines-part-1-docker-hosts/</link><pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate><guid>http://blog.casavian.eu/2019/08/23/meta-pipelines-part-1-docker-hosts/</guid><description>The first step will be to setup an environment where we can run Docker and is the topic for this instalment.
We need at least two kinds of hosts: a Windows and a Linux machines. Simple reason: you cannot run Windows containers on a Linux host, also running Linux containers on a Windows machine is inefficient (they truly run inside a virtual machine). Windows support for Docker is tied to specific kernel versions.</description></item><item><title>Meta-pipelines - Introduction</title><link>http://blog.casavian.eu/2019/08/19/meta-pipelines-introduction/</link><pubDate>Mon, 19 Aug 2019 00:00:00 +0000</pubDate><guid>http://blog.casavian.eu/2019/08/19/meta-pipelines-introduction/</guid><description>Welcome. This series of articles will go in details of automating Azure Pipelines infrastructure itself. The text is accompanied by a source code repository &amp;nbsp; publicly available on GitHub.
Scenario and Problems Imagine yourself in the scenario of an independent team responsible of maintaining its own build pipeline. Typical solutions are:
Grab a leftover desktop or server machine Ask the IT department for a virtual machine Buy a VM in the cloud Use the standard hosted agents provided by Azure Pipelines These solutions share some common problems.</description></item><item><title>Mixing TFVC and Git</title><link>http://blog.casavian.eu/2017/03/04/mixing-tfvc-and-git/</link><pubDate>Sat, 04 Mar 2017 00:00:00 +0000</pubDate><guid>http://blog.casavian.eu/2017/03/04/mixing-tfvc-and-git/</guid><description>It all started because I needed using files coming from a Git repository and additional files stored in classic Team Foundation Version Control (TFVC), all toghether in the same build.
The Options You have three options: the REST API, the tf.exe vc command or &amp;hellip; we will see.
Option 1 – REST API My first attempt relied on a Powershell script to download the files from TFVC using REST API. It worked but performance is not that great as you have to download a file at a time in a loop.</description></item><item><title>Why do you copy all those binaries?</title><link>http://blog.casavian.eu/2014/06/28/why-do-you-copy-all-those-binaries/</link><pubDate>Sat, 28 Jun 2014 00:00:00 +0000</pubDate><guid>http://blog.casavian.eu/2014/06/28/why-do-you-copy-all-those-binaries/</guid><description>Some days ago I replied to StackOverflow question &amp;ldquo;TFS 2010 Build, constant drop location, random access issue &amp;nbsp; &amp;quot;, and it reminded of an approach used in the past that revealed being effective.
The scenario TFS Build creates a new folder in the Drop share at each new Build, no matter if it was successful or completely failed. The folder name is taken from the build identifier generated during the build run, e.</description></item><item><title>Increment Version for Changed Assemblies only – Third Part</title><link>http://blog.casavian.eu/2014/04/28/increment-version-for-changed-assemblies-only-third-part/</link><pubDate>Mon, 28 Apr 2014 00:00:00 +0000</pubDate><guid>http://blog.casavian.eu/2014/04/28/increment-version-for-changed-assemblies-only-third-part/</guid><description>This is the third and last installment of the series: in the First post we examined the basics of extending the MSBuild / Visual Studio process, and in the Second part how to extend the Team Foundation Server Build, so that the minimum set of assembly is recompiled and gets the version updated. The limit of the latter solution is in the version number appearing in the assemblies: they have no relation with build identifiers.</description></item><item><title>Increment Version for Changed Assemblies only – Second Part</title><link>http://blog.casavian.eu/2014/04/25/increment-version-for-changed-assemblies-only-second-part/</link><pubDate>Fri, 25 Apr 2014 00:00:00 +0000</pubDate><guid>http://blog.casavian.eu/2014/04/25/increment-version-for-changed-assemblies-only-second-part/</guid><description>In the previous post we have seen how to hook into the MSBuild process, common to both the Visual Studio and the Team Foundation Server build processes. Now we examine how to leverage the previous achievement in the context of TFS Build.
We will examine the solution in a top-down fashion: first the build definition, than the build template, finally the MSBuild target file. The only drawback, is the lack of correlation between the version number appearing in the output assemblies with the Team Build Identifier; this will be correct with the next post .</description></item><item><title>Increment Version for Changed Assemblies only – First part</title><link>http://blog.casavian.eu/2014/04/23/increment-version-for-changed-assemblies-only-first-part/</link><pubDate>Wed, 23 Apr 2014 00:00:00 +0000</pubDate><guid>http://blog.casavian.eu/2014/04/23/increment-version-for-changed-assemblies-only-first-part/</guid><description>This is something I did in the past (Build incrementale e numeri di versione [ITA] &amp;nbsp; ), and it came out recently on Stack Overflow &amp;nbsp; , so I will take the time to describe how to do this in details.
The solution is design around MSBuild: leveraging some extension points, you trigger the custom code that increments some version number in AssemblyInfo.cs, subject to the same conditions that triggers code compiling.</description></item><item><title>Build workspace issue</title><link>http://blog.casavian.eu/2014/04/02/build-workspace-issue/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>http://blog.casavian.eu/2014/04/02/build-workspace-issue/</guid><description>Some days ago, I got an email from a colleague about a build issue. Here is what she wrote me.
Hi Giulio,
After bringing back the build agents of ___, we’ve experienced below problem
I’ve mentioned you this problem before, we’ve experienced the same when started to use ____ for first time.
Only deleting the workspaces + physical folders fixed it.
I know that many Build Master and TFS Administrators have seen the Unable to create the workspace ___ due to a mapping conflict.</description></item><item><title>Integrating Linux builds in TFS</title><link>http://blog.casavian.eu/2014/02/13/integrating-linux-builds-in-tfs/</link><pubDate>Thu, 13 Feb 2014 00:00:00 +0000</pubDate><guid>http://blog.casavian.eu/2014/02/13/integrating-linux-builds-in-tfs/</guid><description>Once upon a time I had to set-up a demo about integrating TFS build with Linux builds. As many knows there aren&amp;rsquo;t out-of-the-box solutions: currently there are no agents for Linux, so I had to make up something. The solution is composed by the following elements:
setup SSH on Linux write a Linux build script, saved in TFS version control modify the custom template using the Community Build Extensions adding these steps: a.</description></item></channel></rss>